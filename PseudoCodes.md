>[!WARNING]  
>Psuodocodes are generated by github copilot according to my programs . Please check whether the psudocode matches your program before using it.
> [!NOTE]
> For referring the Programs [Click Here](https://github.com/nikhilt77/College)


### Linear Search 

```
PROGRAM LINEARSEARCH

PROCEDURE LINEARSEARCH ACCEPTS array, size, key
    FOR i = 0 TO size - 1
        IF array[i] = key
            RETURN i
        END IF
    END FOR
    RETURN -1
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    READ key
    SET index = LINEARSEARCH(array, size, key)
    IF index != -1
        PRINT "Element found at index ", index
    ELSE
        PRINT "Element not found"
    END IF
END PROCEDURE

END PROGRAM

```
### Binary Search 
```
PROGRAM BINARYSEARCH

PROCEDURE BINARYSEARCH ACCEPTS array, size, key
    SET l = 0
    SET h = size - 1
    WHILE l <= h
        SET mid = (l + h) / 2
        IF array[mid] = key
            RETURN mid
        ELSE IF array[mid] < key
            SET l = mid + 1
        ELSE
            SET h = mid - 1
        END IF
    END WHILE
    RETURN -1
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    READ key
    SET index = BINARYSEARCH(array, size, key)
    IF index != -1
        PRINT "Element found at index ", index
    ELSE
        PRINT "Element not found"
    END IF
END PROCEDURE

END PROGRAM

```

### Bubble Sort 
```
PROGRAM BUBBLESORT

PROCEDURE BUBBLESORT ACCEPTS array, size
    FOR i = 0 TO size - 1
        FOR j = 0 TO size - i - 1
            IF array[j] > array[j + 1]
                SET temp = array[j]
                SET array[j] = array[j + 1]
                SET array[j + 1] = temp
            END IF
        END FOR
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL BUBBLESORT WITH array, size
    PRINT array[size]
END PROCEDURE

END PROGRAM

```

### Repeated Element 
```
PROGRAM REPEATED_ELEMENT

PROCEDURE MAIN
    READ size
    READ array[size]
    SET count = 0
    FOR i = 0 TO size - 1
        FOR j = i + 1 TO size - 1
            IF array[i] = array[j]
                IF j<i
                    BREAK
                END IF
                SET count = count + 1
            END IF
        END FOR
        IF count > 0
            PRINT array[i] " is repeated " count " times"
        END IF
    END FOR
END PROCEDURE

END PROGRAM

```
### Second largest of an array 
```
PROGRAM SECOND_LARGEST

PROCEDURE MAIN
    READ size
    READ array[size]
    SET largest = array[0]
    SET second_largest = array[0]
    FOR i = 0 TO size - 1
        IF array[i] > largest
            SET largest = array[i]
        ELSE 
            SET second_largest = array[i]
        END IF
    END FOR
    PRINT "Second largest element is " second_largest
END PROCEDURE

END PROGRAM

```

### Selection sort 
```
PROGRAM SELECTIONSORT

PROCEDURE SELECTIONSORT ACCEPTS array, size
    FOR i = 0 TO size - 1
        SET min = i
        FOR j = i + 1 TO size - 1
            IF array[min] > array[j]
                SET temp = array[i]
                SET array[i] = array[min]
                SET array[min] = temp
            END IF
        END FOR
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL SELECTIONSORT WITH array, size
    PRINT array
END PROCEDURE

END PROGRAM

```

### Insertion sort 
```
PROGRAM INSERTIONSORT

PROCEDURE INSERTIONSORT ACCEPTS array, size
    FOR i = 1 TO size - 1
        SET key = array[i]
        SET j = i - 1
        WHILE j >= 0 AND array[j] > key
            SET array[j + 1] = array[j]
            SET j = j - 1
        END WHILE
        SET array[j + 1] = key
    END FOR
END PROCEDURE

PROCEDURE MAIN
    READ size
    READ array[size]
    CALL INSERTIONSORT WITH array, size
    PRINT array
END PROCEDURE

END PROGRAM

```

### Polynomial Addition 
```
PROGRAM POLYNOMIAL_ADDITION

DECLARE STRUCTURE POLYNOMIAL
    DECLARE INTEGER coefficient
    DECLARE INTEGER exponent
END STRUCTURE

PROCEDURE READ_POLYNOMIAL ACCEPTS polynomial
    READ number_of_terms
    FOR i = 0 TO number_of_terms - 1
        READ polynomial[i].coefficient
        READ polynomial[i].exponent
    END FOR
    RETURN number_of_terms
END PROCEDURE

PROCEDURE ADD_POLYNOMIAL ACCEPTS polynomial1, polynomial2, result, size1, size2
    SET i = 0
    SET j = 0
    SET k = 0
    WHILE i < size1 AND j < size2
        IF polynomial1[i].exponent = polynomial2[j].exponent
            SET result[k].coefficient = polynomial1[i].coefficient + polynomial2[j].coefficient
            SET result[k].exponent = polynomial1[i].exponent
            SET i = i + 1
            SET j = j + 1
            SET k = k + 1
        ELSE IF polynomial1[i].exponent > polynomial2[j].exponent
            SET result[k].coefficient = polynomial1[i].coefficient
            SET result[k].exponent = polynomial1[i].exponent
            SET i = i + 1
            SET k = k + 1
        ELSE
            SET result[k].coefficient = polynomial2[j].coefficient
            SET result[k].exponent = polynomial2[j].exponent
            SET j = j + 1
            SET k = k + 1
        END IF
    END WHILE
    WHILE i < size1
        SET result[k].coefficient = polynomial1[i].coefficient
        SET result[k].exponent = polynomial1[i].exponent
        SET i = i + 1
        SET k = k + 1
    END WHILE
    WHILE j < size2
        SET result[k].coefficient = polynomial2[j].coefficient
        SET result[k].exponent = polynomial2[j].exponent
        SET j = j + 1
        SET k = k + 1
    END WHILE
    RETURN k
END PROCEDURE

PROCEDURE DISPLAY_POLYNOMIAL ACCEPTS polynomial, size
    FOR i = 0 TO size - 1
        PRINT polynomial[i].coefficient "x^" polynomial[i].exponent
    END FOR
END PROCEDURE

PROCEDURE MAIN
    DECLARE POLYNOMIAL polynomial1[10]
    DECLARE POLYNOMIAL polynomial2[10]
    DECLARE POLYNOMIAL result[10]
    SET size1 = READ_POLYNOMIAL(polynomial1)
    PRINT polynomial1
    SET size2 = READ_POLYNOMIAL(polynomial2)
    PRINT polynomial2
    SET size = ADD_POLYNOMIAL(polynomial1, polynomial2, result, size1, size2)
    DISPLAY_POLYNOMIAL(result, size)
END PROCEDURE

END PROGRAM

```

### Stack 
```
PROGRAM STACK

DEFINE SIZE 10

DECLARE ARRAY stack[SIZE]
SET top = -1

PROCEDURE ISEMPTY 
    IF top == -1
        RETURN TRUE
    ELSE
        RETURN FALSE
    END IF
END PROCEDURE

PROCEDURE ISFULL
    IF top == SIZE - 1
        RETURN TRUE
    ELSE
        RETURN FALSE
    END IF
END PROCEDURE

PROCEDURE PUSH ACCEPTS element
    IF !ISFULL
        SET top = top + 1
        INPUT stack[top]
    ELSE
        PRINT "Stack overflow"
    END IF
END PROCEDURE

PROCEDURE POP
    IF !ISEMPTY
        PRINT stack[top] " is popped"
        SET top = top - 1
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE PEEK
    IF !ISEMPTY
        PRINT stack[top]
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = top TO 0 
            PRINT stack[i]
        END FOR
    ELSE
        PRINT "Stack underflow"
    END IF
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Push"
        PRINT "3. Pop"
        PRINT "4. Peek"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: DISPLAY
            2: READ element
               PUSH(element)
            3: POP
            4: PEEK
            5: EXIT
        END CASE
    END WHILE
END PROCEDURE
END PROGRAM

```

### Queue 
```
PROGRAM QUEUE

DEFINE SIZE 10

DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1

PROCEDURE ISEMPTY
   RETURN front == -1 && rear == -1
END PROCEDURE

PROCEDURE ISFULL
    RETURN rear == SIZE - 1
END PROCEDURE

PROCEDURE ENQUEUE ACCEPTS
    IF ISEMPTY
        SET front = 0
        SET rear = 0
        INPUT queue[rear]
    ELSE IF ISFULL
        PRINT "Queue overflow"
    ELSE
        SET rear = rear + 1
        INPUT queue[rear]
    END IF
END PROCEDURE

PROCEDURE DEQUEUE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE IF front > rear
        PRINT "Cannot dequeue"
    ELSE
        PRINT queue[front] " is dequeued"
        SET front = front + 1
    END IF
END PROCEDURE

PROCEDURE QSIZE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT rear - front + 1
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = front TO rear
            PRINT queue[i]
        END FOR
    ELSE
        PRINT "Queue underflow"
    END IF
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Size"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: DISPLAY
            2: READ element
               ENQUEUE(element)
            3: DEQUEUE
            4: QSIZE
            5: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```

### Sparse Matrix Representation 
```
PROGRAM SPARSE_MATRIX

DEFINE SIZE 10

PROCEDURE MAIN
    DECLARE ARRAY sparse_matrix[SIZE][SIZE]
    READ rows
    READ columns
    READ sparse_matrix[rows][columns]
    DECLARE ARRAY triplet[SIZE*SIZE][3]
    SET count = 0
    SET k = 1
    SET triplet[0][0] = rows
    SET triplet[0][1] = columns

    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            IF sparse_matrix[i][j] != 0
                SET triplet[k][0] = i
                SET triplet[k][1] = j
                SET triplet[k][2] = sparse_matrix[i][j]
                SET k = k + 1
                SET count = count + 1
            END IF
        END FOR
    END FOR

    SET triplet[0][2] = count

    PRINT triplet

END PROCEDURE
END PROGRAM

```

### Sparse Matrix Addition 
```
PROGRAM SPARSE_MATRIX_ADDITION
DEFINE SIZE 10
PROCEDURE INPUTMATRIX ACCEPTS matrix, rows, columns
    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            READ matrix[i][j]
        END FOR
    END FOR
END PROCEDURE
PROCEDURE TRIPLETGEN ACCEPTS matrix, rows, columns, triplet
    SET count = 0
    SET k = 1
    SET triplet[0][0] = rows
    SET triplet[0][1] = columns
    FOR i = 0 TO rows - 1
        FOR j = 0 TO columns - 1
            IF matrix[i][j] != 0
                SET triplet[k][0] = i
                SET triplet[k][1] = j
                SET triplet[k][2] = matrix[i][j]
                SET k = k + 1
                SET count = count + 1
            END IF
        END FOR
    END FOR
    RETURN count
END PROCEDURE
PROCEDURE PRINTTRIPLET ACCEPTS triplet,size
    FOR i = 0 TO size
        FOR j = 0 TO 2
            PRINT triplet[i][j]
        END FOR
    END FOR
END PROCEDURE
PROCEDURE TRIPLETADDITION ACCEPTS triplet1, triplet2, triplet3, size1, size2
    SET i = 1
    SET j = 1
    SET k = 1
    WHILE i <= size1 AND j <= size2
        IF triplet1[i][0] == triplet2[j][0] AND triplet1[i][1] == triplet2[j][1]
            SET triplet3[k][0] = triplet1[i][0]
            SET triplet3[k][1] = triplet1[i][1]
            SET triplet3[k][2] = triplet1[i][2] + triplet2[j][2]
            SET i = i + 1
            SET j = j + 1
            SET k = k + 1
        ELSE IF triplet1[i][0] < triplet2[j][0] OR (triplet1[i][0] == triplet2[j][0] AND triplet1[i][1] < triplet2[j][1])
            SET triplet3[k][0] = triplet1[i][0]
            SET triplet3[k][1] = triplet1[i][1]
            SET triplet3[k][2] = triplet1[i][2]
            SET i = i + 1
            SET k = k + 1
        ELSE
            SET triplet3[k][0] = triplet2[j][0]
            SET triplet3[k][1] = triplet2[j][1]
            SET triplet3[k][2] = triplet2[j][2]
            SET j = j + 1
            SET k = k + 1
        END IF
    END WHILE
    WHILE i <= size1
        SET triplet3[k][0] = triplet1[i][0]
        SET triplet3[k][1] = triplet1[i][1]
        SET triplet3[k][2] = triplet1[i][2]
        SET i = i + 1
        SET k = k + 1
    END WHILE
    WHILE j <= size2
        SET triplet3[k][0] = triplet2[j][0]
        SET triplet3[k][1] = triplet2[j][1]
        SET triplet3[k][2] = triplet2[j][2]
        SET j = j + 1
        SET k = k + 1
    END WHILE
    RETURN k
END PROCEDURE
PROCEDURE MAIN
    DECLARE ARRAY matrix1[SIZE][SIZE]
    DECLARE ARRAY matrix2[SIZE][SIZE]
    READ rows1
    READ columns1
    READ rows2
    READ columns2
    IF(rows1 != rows2 OR columns1 != columns2)
        PRINT "Matrices cannot be added"
        EXIT
    END IF
    INPUTMATRIX(matrix1, rows1, columns1)
    INPUTMATRIX(matrix2, rows2, columns2)

    DECLARE ARRAY triplet1[SIZE*SIZE][3]
    DECLARE ARRAY triplet2[SIZE*SIZE][3]

    SET size1 = TRIPLETGEN(matrix1, rows1, columns1, triplet1)
    SET size2 = TRIPLETGEN(matrix2, rows2, columns2, triplet2)

    PRINTTRIPLET(triplet1, size1)
    PRINTTRIPLET(triplet2, size2)

    DECLARE ARRAY triplet3[SIZE*SIZE][3]
    SET tripet3[0][0] = rows1
    SET tripet3[0][1] = columns1

    SET size3 = TRIPLETADDITION(triplet1, triplet2, triplet3, size1, size2)

    SET triplet3[0][2] = size3 - 1

    PRINTTRIPLET(triplet3, size3)

END PROCEDURE
END PROGRAM

```
### Circular Queue 
```
PROGRAM CIRCULAR_QUEUE

DEFINE SIZE 10

DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1

PROCEDURE ISEMPTY
    RETURN front == -1 && rear == -1
END PROCEDURE

PROCEDURE ISFULL
    RETURN (rear + 1) % SIZE == front
END PROCEDURE

PROCEDURE ENQUEUE ACCEPTS element
    IF !ISFULL
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE
            SET rear = (rear + 1) % SIZE
        END IF
        INPUT queue[rear]
    ELSE
        PRINT "Queue is full"
    END IF
END PROCEDURE

PROCEDURE RESET
    SET front = -1
    SET rear = -1
END PROCEDURE

PROCEDURE DEQUEUE
    IF !ISEMPTY
        PRINT queue[front] " is dequeued"
        IF front == rear
            CALL RESET
        ELSE
            SET front = (front + 1) % SIZE
        END IF
    ELSE
        PRINT "Queue is empty"
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF ISEMPTY
        PRINT "Queue is empty"
        RETURN
    END IF
    SET i = front
    WHILE i != rear
        PRINT queue[i]
        SET i = (i + 1) % SIZE
    END WHILE
    PRINT queue[rear]
END PROCEDURE

PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Exit"
        READ choice
        CASE choice OF
            1: CALL DISPLAY
            2: CALL ENQUEUE
            3: CALL DEQUEUE
            4: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```
### Priority Queue 
```
PROGRAM PRIORITY_QUEUE
DEFINE SIZE 5
DECLARE ARRAY queue[SIZE]
SET front = -1
SET rear = -1
PROCEDURE ISEMPTY
    RETURN front == -1 && rear == -1
END PROCEDURE
PROCEDURE ISFULL
    RETURN rear == SIZE - 1
END PROCEDURE
PROCEDURE ENQUEUE
    IF ISFULL
        PRINT "Queue overflow"
    ELSE
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE
            SET rear = rear + 1
        END IF
        READ key
        SET j = rear - 1
        WHILE j >= 0 AND queue[j] > key
            SET queue[j + 1] = queue[j]
            SET j = j - 1
        END WHILE
        SET queue[j + 1] = key
    END IF
END PROCEDURE
PROCEDURE DEQUEUE
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE IF front > rear
        PRINT "Cannot dequeue"
    ELSE
        PRINT queue[front] " is dequeued"
        SET front = front + 1
    END IF
END PROCEDURE
PROCEDURE SIZE 
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT rear - front + 1
    END IF
END PROCEDURE
PROCEDURE DISPLAY
    IF !ISEMPTY
        FOR i = front TO rear
            PRINT queue[i]
        END FOR
    ELSE
        PRINT "Queue underflow"
    END IF
END PROCEDURE
PROCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Enqueue"
        PRINT "3. Dequeue"
        PRINT "4. Size"
        PRINT "5. Exit"
        READ choice
        CASE choice OF
            1: CALL DISPLAY
            2: CALL ENQUEUE
            3: CALL DEQUEUE
            4: CALL SIZE
            5: CALL EXIT
        END CASE
    END WHILE
END PROCEDURE
END PROGRAM

```
### Double Ended Queue 
```
PROGRAM DEQUE
DEFINE SIZE 10
DECLARE ARRAY Q[SIZE]
SET front = -1
SET rear = -1

PROCEDURE ISEMPTY
    RETURN front == -1 
END PROCEDURE

PROCEDURE ISFULL
    RETURN (rear + 1) % SIZE == front
END PROCEDURE

PROCEDURE ADDREAR 
    IF ISFULL
        PRINT "Queue overflow"
    ELSE
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE
            SET rear = (rear + 1) % SIZE
        END IF
        INPUT Q[rear]
    END IF
END PROCEDURE

PROCEDURE ADDFRONT
    IF ISFULL
        PRINT "Queue overflow"
    ELSE
        IF ISEMPTY
            SET front = 0
            SET rear = 0
        ELSE IF front == 0
            SET front = SIZE - 1
        ELSE
            SET front = front - 1
        END IF
        INPUT Q[front]
    END IF
END PROCEDURE

PRCEDURE REMOVEREAR 
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT Q[rear] " is removed"
        IF front == rear
            SET front = -1
            SET rear = -1
        ELSE IF rear == 0
            SET rear = SIZE - 1
        ELSE
            SET rear = rear - 1
        END IF
    END IF
END PROCEDURE

PROCEDURE REMOVEFRONT
    IF ISEMPTY
        PRINT "Queue underflow"
    ELSE
        PRINT Q[front] " is removed"
        IF front == rear
            SET front = -1
            SET rear = -1
        ELSE 
            SET front = (front + 1) % SIZE
        END IF
    END IF
END PROCEDURE

PROCEDURE DISPLAY
    IF ISEMPTY
        PRINT "Queue is empty"
        RETURN
    END IF
    SET i = front
    WHILE i != rear
        PRINT Q[i]
        SET i = (i + 1) % SIZE
    END WHILE
    PRINT Q[rear]
END PROCEDURE

PROCEDURE SIZE
    DECLARE INTEGER size
    IF ISEMPTY
        SET size = 0
    ELSE IF ISFULL
        SET size = SIZE
    ELSE IF front > rear
        SET size = SIZE - (front - rear) + 1
    ELSE
        SET size = rear - front + 1
    END IF
    PRINT size
END PROCEDURE

PRCEDURE MAIN
    WHILE TRUE
        PRINT "1. Display"
        PRINT "2. Add rear"
        PRINT "3. Add front"
        PRINT "4. Remove rear"
        PRINT "5. Remove front"
        PRINT "6. Size"
        PRINT "7. Exit"
        READ choice
        CASE choice OF
            1: CALL DISPLAY
            2: CALL ADDREAR
            3: CALL ADDFRONT
            4: CALL REMOVEREAR
            5: CALL REMOVEFRONT
            6: CALL SIZE
            7: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```
### Infix to Postfix 
```
PROGRAM INFIX_TO_POSTFIX
DEFINE SIZE 20
DECLARE CHARACTER ARRAY stack[SIZE]
DECLARE CHARACTER ARRAY array[SIZE]

SET top = -1
SET index = -1

PROCEDURE ADDTOARRAY ACCEPTS element
    SET index = index + 1
    SET array[index] = element
END PROCEDURE

PROCEDURE PUSH ACCEPTS element
    SET top = top + 1
    SET stack[top] = element
END PROCEDURE

PROCEDURE POP
    SET top = top - 1
    RETURN stack[top + 1]
END PROCEDURE

PROCEDURE ISOPERATOR ACCEPTS element
    CASE element OF
        '+': RETURN TRUE
        '-': RETURN TRUE
        '*': RETURN TRUE
        '/': RETURN TRUE
        '^': RETURN TRUE
        '(': RETURN TRUE
        ')': RETURN TRUE
        ELSE: RETURN FALSE
    END CASE
END PROCEDURE

PROCEDURE PRIORITY ACCEPTS element
    CASE element OF
        '+': RETURN 1
        '-': RETURN 1
        '*': RETURN 2
        '/': RETURN 2
        '^': RETURN 3
        '(': RETURN 0
    END CASE
END PROCEDURE

PROCEDURE ASSIGN ACCEPTS element
    IF !ISOPERATOR(element)
        CALL ADDTOARRAY(element)
    ELSE
        IF top == -1
            CALL PUSH(element)
        ELSE IF element == ')'
            WHILE stack[top] != '('
                CALL ADDTOARRAY(CALL POP)
            END WHILE
            CALL POP
        ELSE IF element == '(' OR element == '^'
            CALL PUSH(element)
        ELSE
            WHILE PRIORITY(stack[top]) >= PRIORITY(element)
                CALL ADDTOARRAY(CALL POP)
            END WHILE
            CALL PUSH(element)
        END IF
    END IF
END PROCEDURE

PROCEDURE MAIN
    READ expression
    FOR i = 0 TO expression.length - 1
        CALL ASSIGN(expression[i])
    END FOR
    WHILE top != -1
        CALL ADDTOARRAY(CALL POP)
    END WHILE
    PRINT array
END PROCEDURE

END PROGRAM

```
### Postfix Evaluation 
```
PROGRAM POSTFIX_EVALUATION
DEFINE SIZE 20

DECLARE ARRAY stack[SIZE]
SET top = -1

PROCEDURE PUSH ACCEPTS element
    SET top = top + 1
    SET stack[top] = element
END PROCEDURE

PROCEDURE POP
    SET top = top - 1
    RETURN stack[top + 1]
END PROCEDURE

PROCEDURE ISOPERATOR ACCEPTS element
    CASE element OF
        '+': RETURN TRUE
        '-': RETURN TRUE
        '*': RETURN TRUE
        '/': RETURN TRUE
        '^': RETURN TRUE
        ELSE: RETURN FALSE
    END CASE
END PROCEDURE

PROCEDURE EXTRACT ACCEPTS element
    RETURN element - 48
END PROCEDURE

PROCEDURE OPERATE ACCEPTS  operand1,operator, operand2
    CASE operator OF
        '+':  CALL PUSH(operand2 + operand1)
        '-':  CALL PUSH(operand2 - operand1)
        '*':  CALL PUSH(operand2 * operand1)
        '/':  CALL PUSH(operand2 / operand1)
        '^':  CALL PUSH(operand2 ^ operand1)
    END CASE
END PROCEDURE

PROCEDURE ASSIGN ACCEPTS element
    IF ISOPERATOR(element)
        CALL OPERATE(CALL POP,element, CALL POP)
    ELSE
        CALL PUSH(CALL EXTRACT(element))
    END IF
END PROCEDURE

PROCEDURE MAIN
    READ infix_expression
    FOR i = 0 TO SIZE until infix_expression[i] != '\0'
        CALL ASSIGN(infix_expression[i])
    END FOR
    PRINT stack[top]
END PROCEDURE

END PROGRAM

```

### Linked List 
```
PROGRAM LINKED_LIST

DECLARE STRUCTURE NODE
    DECLARE INTEGER data
    DECLARE NODE next
END STRUCTURE

PROCEDURE ADDFRONT ACCEPTS head
    ALLLOCATE newnode
    INPUT newnode->data
    SET newnode->next = head
    SET head = newnode
    RETURN head
END PROCEDURE

PROCEDURE ADDREAR ACCEPTS head
    ALLLOCATE newnode
    SET current = head
    INPUT newnode->data
    SET newnode->next = NULL
    IF current == NULL
        SET head = newnode
    ELSE
        WHILE current->next != NULL
            SET current = current->next
        END WHILE
        SET current->next = newnode
    END IF
    RETURN head
END PROCEDURE

PROCEDURE ADDAFTER ACCEPTS head
    ALLLOCATE newnode
    SET current = head
    INPUT newnode->data
    INPUT key
    IF current == NULL
        PRINT 'List is empty'
    ELSE
        WHILE TRUE
            IF current->data == key
                SET newnode->next = current->next
                SET current->next = newnode
                RETURN;
            END IF
            IF current->next == NULL
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    PRINT 'Cannot find key'
END PROCEDURE

PROCEDURE DELETEFRONT ACCEPTS head
    SET temp = head
    IF head == NULL
        PRINT 'List is empty'
    ELSE
        SET head = current->next
        FREE temp
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DELETEREAR ACCEPTS head
    IF head == NULL
        PRINT 'List is empty'
    ELSE
        SET current = head
        WHILE TRUE
            IF current->next == NULL
                SET temp = current
                SET hed = NULL
                FREE temp
                BREAK
            END IF
            IF current->next->next == NULL
                SET temp = current->next
                SET current->next = NULL
                FREE temp
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DELETEKEY ACCEPTS head
    INPUT key
    SET temp = head
    SET current = head
    IF head == NULL
        PRINT 'List is empty'
    ELSE IF head->data == key
        SET head = head->next
        FREE temp
    ELSE
        WHILE TRUE
            IF current->next->data == key
                SET temp = current->next
                SET current->next = current->next->next
                FREE temp
                RETURN head
            END IF
            IF current->next == NULL
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DISPLAY ACCEPTS head
    IF head == NULL
        PRINT 'List is empty'
    ELSE
        WHILE head != NULL
            PRINT head->data
            SET head = head->next
        END WHILE
    END IF
END PROCEDURE

PROCEDURE MAIN
    DECLARE NODE head
    SET head = NULL
    WHILE TRUE
        PRINT '1. Display'
        PRINT '2. Add front'
        PRINT '3. Add rear'
        PRINT '4. Add after'
        PRINT '5. Delete front'
        PRINT '6. Delete rear'
        PRINT '7. Delete key'
        PRINT '8. Exit'
        READ choice
        CASE choice OF
            1: CALL DISPLAY(head)
            2: SET head = CALL ADDFRONT(head)
            3: SET head = CALL ADDREAR(head)
            4: CALL ADDAFTER(head)
            5: SET head = CALL DELETEFRONT(head)
            6: SET head = CALL DELETEREAR(head)
            7: SET head = CALL DELETEKEY(head)
            8: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```

### Queue using Linked List 
```
PROGRAM QUEUE_USING_LINKED_LIST

DECLARE STRUCTURE NODE
    DECLARE INTEGER data
    DECLARE NODE next
END STRUCTURE

PROCEDURE ENQUEUE ACCEPTS head
    ALLLOCATE newnode
    SET current = head
    INPUT newnode->data
    SET newnode->next = NULL
    IF current == NULL
        SET head = newnode
    ELSE
        WHILE current->next != NULL
            SET current = current->next
        END WHILE
        SET current->next = newnode
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DEQUEUE ACCEPTS head
    IF head == NULL
        PRINT 'Queue underflow'
    ELSE
        SET temp = head
        SET head = head->next
        FREE temp
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DISPLAY ACCEPTS head
    IF head == NULL
        PRINT 'Queue underflow'
    ELSE
        WHILE head != NULL
            PRINT head->data
            SET head = head->next
        END WHILE
    END IF
END PROCEDURE

PROCEDURE MAIN
    DECLARE NODE head
    SET head = NULL
    WHILE TRUE
        PRINT '1. Display'
        PRINT '2. Enqueue'
        PRINT '3. Dequeue'
        PRINT '4. Exit'
        READ choice
        CASE choice OF
            1: CALL DISPLAY(head)
            2: SET head = CALL ENQUEUE(head)
            3: SET head = CALL DEQUEUE(head)
            4: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```

### Stack using Linked List 
```
PROGRAM STACK_USING_LINKED_LIST

DECLARE STRUCTURE NODE
    DECLARE INTEGER data
    DECLARE NODE next
END STRUCTURE

PROCEDURE PUSH ACCEPTS head
    ALLLOCATE newnode
    INPUT newnode->data
    SET newnode->next = head
    SET head = newnode
    RETURN head
END PROCEDURE

PROCEDURE POP ACCEPTS head
    IF head == NULL
        PRINT 'Stack underflow'
    ELSE
        SET temp = head
        SET head = head->next
        FREE temp
    END IF
    RETURN head
END PROCEDURE

PROCEDURE DISPLAY ACCEPTS head
    IF head == NULL
        PRINT 'Stack underflow'
    ELSE
        WHILE head != NULL
            PRINT head->data
            SET head = head->next
        END WHILE
    END IF
END PROCEDURE

PROCEDURE PEEK ACCEPTS head
    IF head == NULL
        PRINT 'Stack underflow'
    ELSE
        PRINT head->data
    END IF
END PROCEDURE

PROCEDURE MAIN
    DECLARE NODE head
    SET head = NULL
    WHILE TRUE
        PRINT '1. Display'
        PRINT '2. Push'
        PRINT '3. Pop'
        PRINT '4. Peek'
        PRINT '5. Exit'
        READ choice
        CASE choice OF
            1: CALL DISPLAY(head)
            2: SET head = CALL PUSH(head)
            3: SET head = CALL POP(head)
            4: CALL PEEK(head)
            5: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```
### Circular Linked List 
```
PROGRAM CIRCULAR_LINKED_LIST

DECLARE STRUCTURE NODE
    DECLARE INTEGER data
    DECLARE NODE next
END STRUCTURE

PROCEDURE ADDFRONT ACCEPTS head
    ALLLOCATE newnode
    INPUT newnode->data
    IF head == NULL
        SET newnode->next = newnode
        SET head = newnode
    ELSE
        SET newnode->next = head
        SET current = head
        WHILE current->next != head
            SET current = current->next
        END WHILE
        SET head = newnode
        SET current->next = newnode
    END IF
    RETURN head
END PROCEDURE

PROCEDURE REMOVEFRONT ACCEPTS head
    IF head == NULL
        PRINT 'List is empty'
    ELSE
        SET current = head
        WHILE current->next != head
            SET current = current->next
        END WHILE
        SET temp = head
        SET head = head->next
        SET current->next = head
        FREE temp
    END IF
    RETURN head
END PROCEDURE

PROCEDURE ADDREAR ACCEPTS head
    SET current = head
    ALLLOCATE newnode
    INPUT newnode->data
    IF head == NULL
        SET newnode->next = newnode
        SET head = newnode
    ELSE
        WHILE current->next != head
            SET current = current->next
        END WHILE
        SET current->next = newnode
        SET newnode->next = head
    END IF

PROCEDURE REMOVEREAR ACCEPTS head
    IF head == NULL
        PRINT 'List is empty'
    ELSE
        SET current = head
        WHILE TRUE
            IF current->next == head
                SET temp = current
                SET head = NULL
                FREE temp
                BREAK
            END IF
            IF current->next->next == head
                SET temp = current->next
                SET current->next = head
                FREE temp
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    RETURN head
END PROCEDURE

PROCEDURE ADDAFTER ACCEPTS head
    ALLLOCATE newnode
    SET current = head
    INPUT newnode->data
    INPUT key
    IF current == NULL
        PRINT 'List is empty'
    ELSE
        WHILE TRUE
            IF current->data == key
                SET newnode->next = current->next
                SET current->next = newnode
                RETURN head
            END IF
            IF current->next == head
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    PRINT 'Cannot find key'
END PROCEDURE

PROCEDURE DELETEKEY ACCEPTS head
    INPUT key
    SET current = head
    IF head == NULL
        PRINT 'List is empty'
        RETURN head
    ELSE 
        WHILE TRUE
            IF current->next->data == key
                SET temp = current->next
                SET current->next = current->next->next
                FREE temp
                RETURN head
            END IF
            IF current->next == head
                BREAK
            END IF
            SET current = current->next
        END WHILE
    END IF
    PRINT 'Cannot find key'
    RETURN head
END PROCEDURE

PROCEDURE DISPLAY ACCEPTS head
    IF head == NULL
        PRINT 'List is empty'
        RETURN
    END IF
    WHILE head->next != head
        PRINT head->data
        SET head = head->next
    END WHILE
    PRINT head->data
END PROCEDURE

PROCEDURE MAIN
    DECLARE NODE head
    SET head = NULL
    WHILE TRUE
        PRINT '1. Display'
        PRINT '2. Add front'
        PRINT '3. Add rear'
        PRINT '4. Add after'
        PRINT '5. Delete front'
        PRINT '6. Delete rear'
        PRINT '7. Delete key'
        PRINT '8. Exit'
        READ choice
        CASE choice OF
            1: CALL DISPLAY(head)
            2: SET head = CALL ADDFRONT(head)
            3: SET head = CALL ADDREAR(head)
            4: CALL ADDAFTER(head)
            5: SET head = CALL REMOVEFRONT(head)
            6: SET head = CALL REMOVEREAR(head)
            7: SET head = CALL DELETEKEY(head)
            8: EXIT
        END CASE
    END WHILE
END PROCEDURE

END PROGRAM

```
### Tree Traversal
```
PROGRAM TREE_TRAVERSAL

DEFINE STRUCTURE Node
    INTEGER key
    DEFINE Node POINTER left
    DEFINE Node POINTER right

DEFINE Node POINTER root = NULL
DEFINE Node POINTER temp = NULL

DEFINE FUNCTION newNode(INTEGER key) RETURNS Node POINTER
    SET Node POINTER node = Allocate memory for Node
    SET node->key = key
    SET node->left = NULL
    SET node->right = NULL
    RETURN node

DEFINE FUNCTION inorder(Node POINTER root)
    IF root != NULL
        CALL inorder(root->left)
        PRINT root->key
        CALL inorder(root->right)

DEFINE FUNCTION preorder(Node POINTER root)
    IF root != NULL
        PRINT root->key
        CALL preorder(root->left)
        CALL preorder(root->right)

DEFINE FUNCTION postorder(Node POINTER root)
    IF root != NULL
        CALL postorder(root->left)
        CALL postorder(root->right)
        PRINT root->key

DEFINE FUNCTION delete(Node POINTER root, INTEGER key)
    IF root == NULL
        RETURN
    IF key < root->key
        CALL delete(root->left, key)
    ELSE IF key > root->key
        CALL delete(root->right, key)
    ELSE
        IF root->left == NULL AND root->right == NULL
            FREE root
            SET root = NULL
        ELSE IF root->left == NULL
            DEFINE Node POINTER temp = root
            SET root = root->right
            FREE temp
        ELSE IF root->right == NULL
            DEFINE Node POINTER temp = root
            SET root = root->left
            FREE temp
        ELSE
            DEFINE INTEGER temp = CALL minimum(root->right)
            SET root->key = temp
            CALL delete(root->right, temp)

DEFINE FUNCTION insert(Node POINTER node, INTEGER key) RETURNS Node POINTER
    IF node == NULL
        RETURN CALL newNode(key)
    IF key < node->key
        SET node->left = CALL insert(node->left, key)
    ELSE IF key > node->key
        SET node->right = CALL insert(node->right, key)
    RETURN node

DEFINE FUNCTION search(Node POINTER root, INTEGER key) RETURNS Node POINTER
    IF root == NULL OR root->key == key
        RETURN root
    IF root->key < key
        RETURN CALL search(root->right, key)
    RETURN CALL search(root->left, key)

DEFINE FUNCTION minimum(Node POINTER root) RETURNS INTEGER
    IF root == NULL
        RETURN 0
    WHILE root->left != NULL
        SET root = root->left
    RETURN root->key

DEFINE FUNCTION maximum(Node POINTER root) RETURNS INTEGER
    IF root == NULL
        RETURN 0
    WHILE root->right != NULL
        SET root = root->right
    RETURN root->key

DEFINE FUNCTION main() RETURNS INTEGER
    DEFINE INTEGER ch, key
    WHILE TRUE
        PRINT "1.Insert 2.Search 3.Minimum 4.Maximum 5.Inorder 6.Preorder 7.Postorder 8.Delete 9.Exit"
        PRINT "Enter your choice:"
        READ ch
        SWITCH ch
            CASE 1:
                PRINT "Enter the key:"
                READ key
                SET root = CALL insert(root, key)
            CASE 2:
                PRINT "Enter the key:"
                READ key
                SET temp = CALL search(root, key)
                IF temp == NULL
                    PRINT "Key not found"
                ELSE
                    PRINT "Key found"
            CASE 3:
                PRINT "Minimum key is ", CALL minimum(root)
            CASE 4:
                PRINT "Maximum key is ", CALL maximum(root)
            CASE 5:
                CALL inorder(root)
            CASE 6:
                CALL preorder(root)
            CASE 7:
                CALL postorder(root)
            CASE 8:
                PRINT "Enter the key:"
                READ key
                CALL delete(root, key)
            CASE 9:
                EXIT program
    RETURN 0
END PROCEDURE
END PROGRAM
```
